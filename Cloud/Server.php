<?php
include './Exception.php';

/**
 * PHP Cloud Server implementation for RackSpace (tm)
 *
 * THIS SOFTWARE IS PROVIDED "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @author Aleksey Korzun <al.ko@webfoundation.net>
 * @link http://github.com/AlekseyKorzun/php-cloudservers/
 * @link http://www.schematic.com
 * @version 0.1
 * @license bsd
 */

class Cloud_Server {
    const METHOD_AUTH = 1;
    const METHOD_POST = 2;
    const METHOD_DELETE = 3;
    const METHOD_PUT = 4;

    private $_apiUser;
    private $_apiKey;
    private $_apiToken;

    protected $_apiServerUri;
    protected $_apiAuthUri = 'https://auth.api.rackspacecloud.com/v1.0';

    protected $_apiResource;
    protected $_apiAgent = 'PHP Cloud Server client';
    protected $_apiJson;
    protected $_apiResponse;
    protected $_apiResponseCode;
    protected $_apiServers = array();
    protected $_apiFlavors = array();
    protected $_apiImages = array();
    protected $_apiFiles = array();

    protected $_enableDebug = false;

    /**
     * Class constructor
     *
     * @param string $apiId user id that will be used for API
     * @param string $apiKey key that was generated by Rackspace
     */
    function __construct($apiId, $apiKey)
    {
        if (!$apiId || !$apiKey) {
            throw new Cloud_Exception('Please provide valid API credentials');
        }

        $this->_apiUser = $apiId;
        $this->_apiKey = $apiKey;
    }

    /**
     * Performs CURL requests (POST,PUT,DELETE,GET) required by API.
     *
     * @param string $method HTTP method that will be used for current request
     * @throws Cloud_Exception
     */
    private function _doRequest($method = null)
    {
        if (!$this->_apiToken && $method != self::METHOD_AUTH) {
            $this->_doRequest(self::METHOD_AUTH);
        }

        $curl = curl_init();

        $headers = array(
            sprintf("%s: %s", 'X-Auth-Token', $this->_apiToken),
            sprintf("%s: %s", 'Content-Type', 'application/json'));

        curl_setopt($curl, CURLOPT_URL, $this->_apiServerUri.$this->_apiResource);

        switch ($method) {
            case self::METHOD_POST:
                curl_setopt($curl, CURLOPT_POST, true);
                curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($this->_apiJson));
            break;
            case self::METHOD_PUT:
                curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "PUT");
                array_push($headers, json_encode($this->_apiJson));
            break;
            case self::METHOD_DELETE:
                curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "DELETE");
            break;
            case self::METHOD_AUTH:
                $headers = array(
                    sprintf("%s: %s", 'X-Auth-User', $this->_apiUser),
                    sprintf("%s: %s", 'X-Auth-Key', $this->_apiKey));
                curl_setopt($curl, CURLOPT_URL, $this->_apiAuthUri);
                curl_setopt($curl, CURLOPT_HEADERFUNCTION, array(&$this,'_requestAuth'));
            break;
            default:
                // By default we request data using GET method
                $headers = array(
                    sprintf("%s: %s", 'X-Auth-Token', $this->_apiToken));
            break;
        }

        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
        curl_setopt($curl, CURLOPT_HEADER, 0);
        curl_setopt($curl, CURLOPT_USERAGENT, $this->_apiAgent);
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

        // If debug is enabled we will output CURL data to screen
        if ($this->_enableDebug) {
            curl_setopt($curl, CURLOPT_VERBOSE, 1);
        }

        $this->_apiResponse = json_decode(curl_exec($curl));

        // Also for debugging purposes output response we got
        if ($this->_enableDebug) {
            var_dump($this->_apiResponse);
        }

        if (curl_errno($curl) > 0) {
            throw new Cloud_Exception('Unable to process this request');
        }

        // Retrieve returned HTTP code and throw exceptions when possible
        // error occurs.
        //
        // @todo This needs a little bit more work
        $curlInfo = curl_getinfo($curl);
        if (!empty($curlInfo['http_code'])) {
            $this->_apiResponseCode = (int) $curlInfo['http_code'];
            switch ($this->_apiResponseCode) {
                case '401':
                    // User is no longer authorized, re-authenicate with API
                    $this->_doRequest(self::METHOD_AUTH);
                    $this->_doRequest($method);
                break;
                case '400':
                    throw new Cloud_Exception('Access is denied for the given request. Check your X-Auth-Token header. The token may have expired.');
                break;
                case '404':
                    throw new Cloud_Exception('The server has not found anything matching the Request URI.');
                break;
                case '403':
                    throw new Cloud_Exception('Access is denied for the given request.');
                break;
                case '413':
                    throw new Cloud_Exception('The server is refusing to process a request because the request entity is larger than the server is willing or able to process.');
                break;
                case '500':
                    throw new Cloud_Exception('The server encountered an unexpected condition which prevented it from fulfilling the request.');
                break;
            }
        }
        curl_close($curl);
    }
    /**
     * This method is used for processing authentication response.
     *
     * Basically we retrieve authentication token and server management
     * URI from returned headers.
     *
     * @param mixed $ch instance of curl
     * @param string $header
     * @return int leight of header
     */
    private function _requestAuth($ch, $header)
    {
        if (stripos($header, 'X-Auth-Token') === 0) {
            $this->_apiToken = trim(substr($header, strlen('X-Auth-Token')+1));
        }
        if (stripos($header, 'X-Server-Management-Url') === 0) {
            $this->_apiServerUri = trim(substr($header, strlen('X-Server-Management-Url')+1));
        }

        return strlen($header);
    }

    /**
     * Enables debugging output
     *
     * @return null
     */
    public function enableDebug()
    {
        $this->_enableDebug = true;
    }

    /**
     * Disabled debugging output
     *
     * @return null
     */
    public function disableDebug()
    {
        $this->_enableDebug = false;
    }

    /**
     * Retrieves details regarding specific server flavor
     */
    public function getFlavor ($flavorId)
    {
        $this->_apiResource = '/flavors/'. (int) $flavorId;
        $this->_doRequest();

        if ($this->_apiResponseCode && ($this->_apiResponseCode == '200'
                || $this->_apiResponseCode == '203')) {
            if ($this->_apiResponse->flavor) {
                $this->_apiFlavors[(int) $flavorId] = array(
                        'name' => (string) $this->_apiResponse->flavor->name,
                        'disk' => (string) $this->_apiResponse->flavor->disk,
                        'ram' => (string) $this->_apiResponse->flavor->ram);
                return $this->_apiFlavors[(int) $flavorId];
            }
        }
    }

    /**
     * Retrieves all of the available server flavors
     *
     * @return array returns an array of currently available server configurations
     */
    public function getFlavors ()
    {
        $this->_apiResource = '/flavors';
        $this->_doRequest();

        if ($this->_apiResponseCode && ($this->_apiResponseCode == '200'
                    || $this->_apiResponseCode == '203')) {
            if ($this->_apiResponse->flavors) {
                $this->_apiFlavors = array();
                foreach ($this->_apiResponse->flavors as $flavor) {
                    $this->_apiFlavors[(int) $flavor->id]['name']
                        = (string) $flavor->name;
                }
                return $this->_apiFlavors;
            }
        }
    }

    /**
     * Creates a new image of server
     *
     * @param string $name name of new image
     * @param int $serverId server id for which you wish to base this image on
     * @return array details of created image
     */
    public function createImage ($name, $serverId)
    {
        $this->_apiResource = '/images';
        $this->_apiJson = array ('image' => array(
                                    'serverId' => (int) $serverId,
                                    'name' => (string) $name));
        $this->_doRequest(self::METHOD_POST);

        if ($this->_apiResponseCode && $this->_apiResponseCode == '200') {
            if ($this->_apiResponse->image) {
                $this->_apiImages[(int) $this->_apiResponse->image->id] = array(
                      'serverId' => (int)$this->_apiResponse->image->serverId,
                      'name' => (string) $this->_apiResponse->image->name,
                      'id' => (int) $this->_apiResponse->image->id);
                return $this->_apiImages[(int) $this->_apiResponse->image->id];
            }
        }
    }

    /**
     * Retrieves details of specific image
     *
     * @param int $imageId id of image you wish to retrieve details for
     * @return array details of requested image
     */
    public function getImage ($imageId)
    {
        $this->_apiResource = '/images/'. (int) $imageId;
        $this->_doRequest();

        if($this->_apiResponseCode && ($this->_apiResponseCode == '200'
                || $this->_apiResponseCode == '203')) {
            if ($this->_apiResponse->image) {
                $this->_apiImages[(int) $imageId] = array(
                        'name' => (string) $this->_apiResponse->image->name,
                        'status' => (string) $this->_apiResponse->image->status,
                        'created' => (string) $this->_apiResponse->image->created,
                        'updated' => (string) $this->_apiResponse->image->updated);
                return $this->_apiImages[(int) $imageId];
            }
        }
    }

    /**
     * Retrieves all of the available images
     *
     * @return array returns array of available images
     */
    public function getImages ()
    {
        $this->_apiResource = '/images';
        $this->_doRequest();

        if ($this->_apiResponseCode && ($this->_apiResponseCode == '200'
                || $this->_apiResponseCode == '203')) {
            if ($this->_apiResponse->images) {
                // Reset internal image array
                $this->_apiImages = array();
                foreach($this->_apiResponse->images as $image) {
                    $this->_apiImages[(int) $image->id]['name'] = (string) $image->name;
                }
                return $this->_apiImages;
            }
        }
    }

    public function getServer ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId;
        $this->_doRequest();

        if ($this->_apiResponseCode && $this->_apiResponseCode == '200') {
            if ($this->_apiResponse->server) {
                $this->_apiServers[(int) $this->_apiResponse->server->id] =
                    array('id' => (int) $this->_apiResponse->server->id,
                           'name' => (string) $this->_apiResponse->server->name,
                           'imageId' => (int) $this->_apiResponse->server->imageId,
                           'flavorId' => (int) $this->_apiResponse->server->flavorId,
                           'hostId' => (string) $this->_apiResponse->server->hostId,
                           'progress' => (int) $this->_apiResponse->server->progress,
                           'status' => (string) $this->_apiResponse->server->status,
                           'addresses' => array(),
                           'metadata' => array());
                if ($this->_apiResponse->server->addresses->public) {
                    foreach ($this->_apiResponse->server->addresses->public as $public) {
                        $this->_apiServers[(int) $this->_apiResponse->server->id]['addresses']['public'][]
                            = (string) $public;
                    }
                }
                if ($this->_apiResponse->server->addresses->private) {
                    foreach ($this->_apiResponse->server->addresses->private as $private) {
                        $this->_apiServers[(int) $this->_apiResponse->server->id]['addresses']['private'][]
                            = (string) $private;
                    }
                }
                if ($this->_apiResponse->server->metadata) {
                    foreach ($this->_apiResponse->server->metadata as $key => $value) {
                        $this->_apiServers[(int) $this->_apiResponse->server->id]['metadata'][(string) $key]
                            = (string) $value;
                    }
                }

                return $this->_apiServers[(int) $this->_apiResponse->server->id];
            }
        }
    }

    public function getServers ()
    {
        $this->_apiResource = '/servers';
        $this->_doRequest();

        if ($this->_apiResponseCode && $this->_apiResponseCode == '200') {
            if (!empty($this->_apiResponse->servers)) {
                $this->_apiServers = array();
                foreach ($this->_apiResponse->servers as $server) {
                    $this->_apiServers[(int) $server->id]['name'] = (string) $server->name;
                }
                return $this->_apiServers;
            }
        }
    }

    /**
     * Retrieves current API limits
     *
     * @todo Need to smartly check limits before making requests
     * @return stdClass object containing current limits
     */
    public function getLimits ()
    {
        $this->_apiResource = '/limits';
        $this->_doRequest();

        if ($this->_apiResponseCode && $this->_apiResponseCode == '200') {
            return $this->_apiResponse;
        }
    }

    public function getServerIp ($serverIp, $type = false)
    {
       $this->_apiResource = '/servers/'.(int) $serverIp.'/ips'.($type ? '/'.$type : '');
       $this->_doRequest();
    }

    public function setServerIp ($serverId, $serverIp, $groupId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/ips/public/'. $serverIp;
        $this->_apiJson = array ('shareIp' => array(
                                    'sharedIpGroupId' => (int) $groupId,
                                    'configureServer' => 'true'));
        $this->_doRequest(self::METHOD_PUT);
    }

    public function deleteServerIp ($serverId, $serverIp)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/ips/public/'.$serverIp;
        $this->_doRequest(self::METHOD_PUT);
    }

    public function getSharedIpGroup ($isDetailed = false, $groupId = false)
    {
        $this->_apiResource = '/shared_ip_groups'. ($isDetailed ? '/detail' : '');
        if(is_numeric($groupId)) {
            $this->_apiResource = $this->_apiResource .'/'. (int) $groupId;
        }
        $this->_doRequest();
    }

    public function deleteSharedIpGroup ($groupId)
    {
        $this->_apiResource = '/shared_ip_groups/'. (int) $groupId;
        $this->_doRequest(self::METHOD_DELETE);
    }

    public function addSharedIpGroup ($name, $serverId)
    {
        $this->_apiResource = '/shared_ip_groups';
        $this->_apiJson = array ('sharedIpGroup' => array(
                                    'name' => (string) $name,
                                    'server' => (int) $serverId));
        $this->_doRequest(self::METHOD_POST);
    }

    public function getBackupSchedule ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/backup_schedule';
        $this->_doRequest();
    }

    public function addBackupSchedule ($serverId, $weekly, $daily, $isEnabled)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/backup_schedule';
        $this->_apiJson = array ('backup' => array(
                                    'enabled' => (string) $isEnabled,
                                    'weekly' => (string) $weekly,
                                    'daily' => (string) $daily));
        $this->_doRequest(self::METHOD_POST);
    }

    public function deleteBackupSchedule ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/backup_schedule';
        $this->_doRequest(self::METHOD_DELETE);
    }

    public function createServer ($name, $imageId, $flavorId, $groupId = false)
    {
        $name = preg_replace("/[^a-zA-Z0-9s]/", '', $name);

        // We need to check if we are creating a dublicate server name,
        // since creating two servers with same name can cause problems.
        if (empty($this->_apiServers)) {
            $this->getServers();
        }

        foreach ($this->_apiServers as $server) {
            if (strtolower($server['name']) == strtolower($name)) {
                throw new Cloud_Exception ('Server with name: '. $name .' already exists!');
            }
        }

        $this->_apiResource = '/servers.xml';
        $this->_apiJson = array ('server' => array(
                                'name' => (string) $name,
                                'imageId' => (int) $imageId,
                                'flavorId' => (int) $flavorId,
                                'metadata' => array(
                                    'Server Name' => (string) $name),
                                'personality' => array()));

        if (is_array($this->_apiFiles) && !empty($this->_apiFiles)) {
            foreach ($this->_apiFiles as $file => $content) {
                array_push($this->_apiJson['server']['personality'],
                   array('path' => $file, 'contents' => base64_encode($content)));
            }
        }

        if (is_numeric($groupId)) {
            array_push($this->_apiJson['server'], array('sharedIpGroupId' => (int) $groupId));
        }

        $this->_doRequest(self::METHOD_POST);

        // If server was created, store it locally
        if ($this->_apiResponseCode && $this->_apiResponseCode == '202') {
            // Reset file array
            $this->_apiFiles = array();

            $serverXml = simplexml_load_string($this->_apiResponse);
            if (!empty($serverXml)) {
                $this->_apiServers[(int) $serverXml['id']] =
                    array('name' => (string) $serverXml['name'],
                            'imageId' => (int) $serverXml['imageId'],
                            'flavorId' => (int) $serverXml['flavorId'],
                            'hostId' => (string) $serverXml['hostId'],
                            'progress' => (int) $serverXml['progress'],
                            'status' => (string) $serverXml['status'],
                            'addresses' => array(),
                            'metadata' => array());
                if ($serverXml->addresses->public) {
                    foreach ($serverXml->addresses->public as $public) {
                        $this->_apiServers[(int) $serverXml['id']]['addresses']['public'][]
                            = (string) $public->ip['addr'];
                    }
                }
                if ($serverXml->addresses->private) {
                    foreach ($serverXml->addresses->private as $private) {
                        $this->_apiServers[(int) $serverXml['id']]['addresses']['private'][]
                            = (string) $private->ip['addr'];
                    }
                }
                return $this->_apiServers[(int) $serverXml['id']];
            }
        }
    }

    public function addServerFile ($file, $content) {
        $this->_apiFiles[(string) $file] = (string) $content;
        return $this->_apiFiles;
    }

    public function updateServer ($serverId, $name, $password)
    {
        $this->_apiResource = '/servers/'. (int) $serverId;
        $this->_apiJson = array ('server' => array(
                                    'name' => (string) $name,
                                    'adminPass' => (string) $password));
        $this->_doRequest(self::METHOD_PUT);


        // If server was updated, update it locally
        if ($this->_apiResponseCode && $this->_apiResponseCode == '202') {
            $this->_apiServers[(int) $serverId]['name']= (string) $name;
            $this->_apiServers[(int) $serverId]['adminPass']= (string) $password;

            return $this->_apiServers[(int) $serverId];
        }
    }

    public function deleteServer ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId;
        $this->_doRequest(self::METHOD_DELETE);

        // If server was deleted, update it locally
        if ($this->_apiResponseCode && $this->_apiResponseCode == '202') {
            unset($this->_apiServers[(int) $serverId]);
        }
    }

    public function rebuildServer ($serverId, $imageId)
    {
        $this->_apiResource = '/servers/' . (int) $serverId .'/action';
        $this->_apiJson = array ('rebuild' => array(
                                    'imageId' => (int) $imageId));
        $this->_doRequest(self::METHOD_PUT);
    }

    public function resizeServer ($serverId, $flavorId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/action';
        $this->_apiJson = array ('resize' => array(
                                    'flavorId' => (int) $flavorId));
        $this->_doRequest(self::METHOD_PUT);
    }

    public function confirmResize ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/action';
        $this->_apiJson = array ('confirmResize' => '1');
        $this->_doRequest(self::METHOD_PUT);
    }

    public function revertResize ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/action';
        $this->_apiJson = array ('revertResize' => '1');
        $this->_doRequest(self::METHOD_PUT);
    }

    public function rebootServer ($serverId)
    {
        $this->_apiResource = '/servers/'. (int) $serverId .'/action';
        $this->_apiJson = array ('reboot' => array(
                                    'type' => 'HARD'));
        $this->_doRequest(self::METHOD_POST);
    }
}