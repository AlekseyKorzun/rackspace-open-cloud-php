<?php
namespace Cloud;

use Cloud\Server\Exception;

/**
 * PHP Cloud Server implementation for RackSpace (tm)
 *
 * THIS SOFTWARE IS PROVIDED "AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @throws Exception
 * @package Cloud
 * @version 0.3
 * @license bsd
 * @author Aleksey Korzun <al.ko@webfoundation.net>
 * @link http://github.com/AlekseyKorzun/php-cloudservers/
 * @link http://www.alekseykorzun.com
 */
class Server
{
	/**
	 * Authentication method
	 *
	 * @var int
	 */
	const METHOD_AUTH = 1;

	/**
	 * Post method
	 *
	 * @var int
	 */
	const METHOD_POST = 2;

	/**
	 * Delete method
	 *
	 * @var int
	 */
	const METHOD_DELETE = 3;

	/**
	 * Put method
	 *
	 * @var int
	 */
	const METHOD_PUT = 4;

	/**
	 * User agent for our client
	 *
	 * @var string
	 */
	const USER_AGENT = 'PHP Cloud Server client v0.3';

	/**
	 * API's user credentials
	 *
	 * @var string
	 */
	private $username;

	/**
	 * Private key
	 *
	 * @var string
	 */
	private $key;

	/**
	 * Token issued by API server
	 * @var string
	 */
	private $token;

	/**
	 * Internal storage for server management URI
	 *
	 * @var string
	 */
	protected $serverUri;

	/**
	 * Internal storage for authentication URI's
	 *
	 * @var array
	 */
	protected $authUris = array(
		'UK' => 'https://lon.auth.api.rackspacecloud.com/v1.0',
		'US' => 'https://auth.api.rackspacecloud.com/v1.0'
	);

	/**
	 * Location of API
	 *
	 * @var string
	 */
	protected $location;

	/**
	 * Hard coded back up schedules
	 *
	 * @var array
	 */
	protected $backupSchedules = array(
		'weekly' => array(
							'DISABLED',
							'SUNDAY',
							'MONDAY',
							'TUESDAY',
							'WEDNESDAY',
							'THURSDAY',
							'FRIDAY',
							'SATURDAY'
					),
		'daily' => array(
							'DISABLED',
							'H_0000_0200',
							'H_0200_0400',
							'H_0400_0600',
							'H_0600_0800',
							'H_0800_1000',
							'H_1000_1200',
							'H_1400_1600',
							'H_1600_1800',
							'H_1800_2000',
							'H_2000_2200',
							'H_2200_0000'
						)
	);

	/**
	 * Dynamic API resource (end-point)
	 *
	 * @var string
	 */
	protected $resource;

	/**
	 * Generated JSON data we send off to API
	 *
	 * @var string
	 */
	protected $request;

	/**
	 * Stored response we received back from API
	 *
	 * @var string
	 */
	protected $response;

	/**
	 * Stored response code we recieved back from API
	 *
	 * @var int
	 */
	protected $responseCode;

	/**
	 * Internal array that stores all of the cloud servers you interacted with
	 * for chained commands
	 *
	 * @var array
	 */
	protected $servers = array();

	/**
	 * Internal array that stores all of the files you interacted with
	 * for chained commands
	 *
	 * @var array
	 */
	protected $files = array();

	/**
	 * Debugging flag
	 *
	 * @var bool
	 */
	protected $enableDebug = false;

	/**
	 * Class constructor
	 *
	 * @throws Exception
	 * @param string $username user id that will be used for API
	 * @param string $key key that was generated by Rackspace
	 * @param string $location location of API use wish to use
	 * @return void
	 */
	public function __construct($username, $key, $location = 'US')
	{
		if (!$username || !$key) {
			throw new Exception('Please provide valid API credentials');
		}

		$this->username = $username;
		$this->key = $key;
		$this->location = $location;
	}

	/**
	 * Get authentication token
	 *
	 * @return mixed return authentication token or false on failure
	 */
	public function getToken()
	{
		if (!empty($this->token)) {
			return $this->token;
		}

		return false;
	}

	/**
	 * Set authentication token
	 *
	 * @param string $tokenId token you wish to set
	 * @return void
	 */
	public function setToken($tokenId)
	{
		$this->token = $tokenId;
	}

	/**
	 * Perform authentication
	 *
	 * @return string returns recieved token
	 */
	public function authenticate ()
	{
		$this->request(self::METHOD_AUTH);
		return $this->token;
	}

	/**
	 * Performs cURL requests (POST,PUT,DELETE,GET) required by API.
	 *
	 * @throws Exception
	 * @param string $method HTTP method that will be used for current request
	 * @return void
	 */
	private function request($method = null)
	{
		if (!$this->token && $method != self::METHOD_AUTH) {
			$this->request(self::METHOD_AUTH);
		}

		$curl = curl_init();

		$headers = array(
			sprintf("%s: %s", 'X-Auth-Token', $this->token),
			sprintf("%s: %s", 'Content-Type', 'application/json')
		);

		curl_setopt($curl, CURLOPT_URL, $this->serverUri . $this->resource);

		switch ($method) {
			case self::METHOD_POST:
				curl_setopt($curl, CURLOPT_POST, true);
				curl_setopt($curl, CURLOPT_POSTFIELDS, json_encode($this->request));
				break;
			case self::METHOD_PUT:
				curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "PUT");
				array_push($headers, json_encode($this->request));
				break;
			case self::METHOD_DELETE:
				curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "DELETE");
				break;
			case self::METHOD_AUTH:
				$headers = array(
					sprintf("%s: %s", 'X-Auth-User', $this->username),
					sprintf("%s: %s", 'X-Auth-Key', $this->key));
				curl_setopt($curl, CURLOPT_URL, $this->authUris[$this->location]);
				curl_setopt($curl, CURLOPT_HEADERFUNCTION, array(&$this,'requestAuth'));
				break;
			default:
				// By default we request data using GET method
				$headers = array(
									sprintf("%s: %s", 'X-Auth-Token', $this->token)
								);
		}

		curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);
		curl_setopt($curl, CURLOPT_HEADER, 0);
		curl_setopt($curl, CURLOPT_USERAGENT, $this->agent);
		curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);

		// If debug is enabled we will output CURL data to screen
		if ($this->enableDebug) {
			curl_setopt($curl, CURLOPT_VERBOSE, 1);
		}

		$this->response = curl_exec($curl);

		// Also for debugging purposes output response we got
		if ($this->enableDebug) {
			var_dump($this->response);
		}

		if (curl_errno($curl) > 0) {
			throw new Exception(
				'Unable to process this request. curl err: ' . curl_errno($curl)
			);
		}

		// Retrieve returned HTTP code and throw exceptions when possible
		// error occurs
		$curlInfo = curl_getinfo($curl);
		if (!empty($curlInfo['http_code'])) {
			$this->responseCode = (int) $curlInfo['http_code'];
			switch ($this->responseCode) {
				case '401':
					// User is no longer authorized, re-authenicate with API
					$this->request(self::METHOD_AUTH);
					$this->request($method);
					break;
				case '400':
					throw new Exception(
						'Access is denied for the given request. Check your X-Auth-Token header. The token may have expired.'
					);
					break;
				case '404':
					throw new Exception(
						'The server has not found anything matching the Request URI.'
					);
					break;
				case '403':
					throw new Exception(
						'Access is denied for the given request.'
					);
					break;
				case '413':
					throw new Exception(
						'The server is refusing to process a request because the request entity is larger than the server is willing or able to process.'
					);
					break;
				case '500':
					throw new Exception(
						'The server encountered an unexpected condition which prevented it from fulfilling the request.'
					);
					break;
			}
		}
		curl_close($curl);
	}

	/**
	 * This method is used for processing authentication response.
	 *
	 * Basically we retrieve authentication token and server management
	 * URI from returned headers.
	 *
	 * @param mixed $curl instance of cURL
	 * @param string $header
	 * @return int length of header
	 */
	private function requestAuth($curl, $header)
	{
		if (stripos($header, 'X-Auth-Token') === 0) {
			$this->token = trim(substr($header, strlen('X-Auth-Token')+1));
		}
		if (stripos($header, 'X-Server-Management-Url') === 0) {
			$this->serverUri = trim(substr($header, strlen('X-Server-Management-Url')+1));
		}

		return strlen($header);
	}

	/**
	 * Enables debugging output
	 *
	 * @return void
	 */
	public function enableDebug()
	{
		$this->enableDebug = true;
	}

	/**
	 * Disable debugging output
	 *
	 * @return void
	 */
	public function disableDebug()
	{
		$this->enableDebug = false;
	}

	/**
	 * Retrieves details regarding specific server flavor
	 *
	 * @param int $flavorId id of a flavor you wish to retrieve details for
	 * @return mixed returns JSON string containing details for requested
	 * flavor or false on failure
	 */
	public function getFlavor($flavorId)
	{
		$this->resource = '/flavors/' . (int) $flavorId;
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves all of the available server flavors
	 *
	 * @param bool $isDetailed requested detailed description of server flavors
	 * @return mixed returns json string containing available server configurations or
	 * false on failure
	 */
	public function getFlavors($isDetailed = false)
	{
		$this->resource = '/flavors' . ($isDetailed ? '/detail' : '');
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Creates a new image of server
	 *
	 * @param string $name name of new image
	 * @param int $serverId server id for which you wish to base this
	 * image on
	 * @return mixed returns json string containing details of created
	 * image or false on failure
	 */
	public function createImage($name, $serverId)
	{
		$this->resource = '/images';
		$this->request = array(
			'image' => array(
								'serverId' => (int) $serverId,
								'name' => (string) $name
							)
		);

		$this->request(self::METHOD_POST);

		if ($this->responseCode == 200) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves details of specific image
	 *
	 * @param int $imageId id of image you wish to retrieve details for
	 * @return json string containing details of requested image
	 */
	public function getImage($imageId)
	{
		$this->resource = '/images/' . (int) $imageId;
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves all of the available images
	 *
	 * @param bool $isDetailed should API return more detailed
	 * image descriptions for available images
	 * @return mixed returns json string of available images or false
	 * on failure
	 */
	public function getImages($isDetailed = false)
	{
		$this->resource = '/images' . ($isDetailed ? '/detail' : '');
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves configuration details for specific server
	 *
	 * @param int $serverId id of server this action is performed for
	 * @return mixed json string containing server details or false
	 * on failure
	 */
	public function getServer($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId;
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			// Save server names to avoid creating duplicate servers
			if (property_exists($this->response, 'server')) {
				$this->servers[(int) $this->response->server->id] =
					array('id' => (int) $this->response->server->id,
							'name' => (string) $this->response->server->name);
			}

			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves currently available servers
	 *
	 * @param bool $isDetailed should API return more detailed server descriptions
	 * for available servers
	 * @return mixed json string containing current servers or false on failure
	 */
	public function getServers($isDetailed = false)
	{
		$this->resource = '/servers'. ($isDetailed ? '/detail' : '');
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			if (property_exists($this->response, 'servers')) {
				// Reset internal server array
				$this->servers = array();
				foreach ($this->response->servers as $server) {
					$this->servers[(int) $server->id]['name'] = (string) $server->name;
				}
			}

			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieves current API limits
	 *
	 * @return mixed json string containing current limits or false on failure
	 */
	public function getLimits()
	{
		$this->resource = '/limits';
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Share servers IP address
	 *
	 * @param int $serverId id of server this action is performed for
	 * @param string $serverIp IP you wish to unshare
	 * @param int $groupId optional group id of shared server
	 * @param int $doConfigure automaticly configure server
	 * @return bool returns true on success or false on failure
	 */
	public function shareServerIp($serverId, $serverIp, $groupId, $doConfigure = false)
	{
		$this->resource = '/servers/' . (int) $serverId
									. '/ips/public/' . $serverIp;
		$this->request = array ('shareIp' => array(
									'sharedIpGroupId' => (int) $groupId,
									'configureServer' => (bool) $doConfigure));
		$this->request(self::METHOD_PUT);

		if ($this->responseCode == 201) {
			return true;
		}

		return false;
	}

	/**
	 * Removes a shared server IP from server
	 *
	 * @param int $serverId id of server this action is performed for
	 * @param string $serverIp IP you wish to unshare
	 * @return bool returns true on success or false on failure
	 */
	public function unshareServerIp($serverId, $serverIp)
	{
		$this->resource = '/servers/' . (int) $serverId
									. '/ips/public/' . (string) $serverIp;
		$this->request(self::METHOD_DELETE);

		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Get IP's assigned to server
	 *
	 * @param int $serverId id of server you wish to retrieve ips for
	 * @param string $type type of addresses to retrieve could be
	 * private/public or false for both types.
	 * @return mixed returns json string of server addresses or false
	 * of failure
	 */
	public function getServerIp($serverId, $type = null)
	{
		$this->resource = '/servers/' . (int) $serverId . '/ips'
									. ($type ? '/' . $type : '');
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Add a server to shared ip group
	 *
	 * @param string $name name of shared ip group you are creating
	 * @param int $serverId id of server you wish to add to this group
	 * @return mixed returns json string containing id of created shared
	 * ip group or false on failure
	 */
	public function addSharedIpGroup($name, $serverId)
	{
		$this->resource = '/shared_ip_groups';
		$this->request = array('sharedIpGroup' => array(
									'name' => (string) $name,
									'server' => (int) $serverId));
		$this->request(self::METHOD_POST);

		if ($this->responseCode == 201) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Delete shared IP group
	 *
	 * @param int $groupId id of group you wish to delete
	 * @return bool returns true on success and false on failure
	 */
	public function deleteSharedIpGroup($groupId)
	{
		$this->resource = '/shared_ip_groups/' . (int) $groupId;
		$this->request(self::METHOD_DELETE);

		if ($this->responseCode == 204) {
			return true;
		}

		return false;
	}

	/**
	 * Retrieve details for specific IP group
	 *
	 * @param int $groupId id of specific shared group you wish to
	 * retrieve details for
	 * @return mixed returns json string containing details about
	 * requested group or false on failure
	 */
	public function getSharedIpGroup($groupId)
	{
		$this->resource = '/shared_ip_groups/' . (int) $groupId;
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieve all the available shared IP groups
	 *
	 * @param bool $isDetailed should response contain an array of
	 * servers group has
	 * @return mixed returns json string of groups or false on failure
	 */
	public function getSharedIpGroups($isDetailed = false)
	{
		$this->resource = '/shared_ip_groups'
									. ($isDetailed ? '/detail' : '');
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Retrieve back-up schedule for a specific server
	 *
	 * @param int $serverId id of server you wish to retrieve back-up
	 * schedule for
	 * @return mixed returns json string of current back-up schedule or
	 * false on failure
	 */
	public function getBackupSchedule($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId
									. '/backup_schedule';
		$this->request();

		if ($this->responseCode == 200 || $this->responseCode == 203) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Create a new back-up schedule for a server
	 *
	 * @throws Exception
	 * @param int $serverId id of a server this back-up schedule is
	 * intended for
	 * @param string $weekly day of the week this back-up should run,
	 * look at $backupSchedules array and/or documentation for valid parameters
	 * @param string $daily time of the day this back-up should run,
	 * look at $backupSchedules array and/or documentation for valid parameters
	 * @param bool $isEnabled should this scheduled back-up be enabled
	 * or disabled, default is set to enabled.
	 * @return bool true on success and false on failure
	 */
	public function addBackupSchedule($serverId, $weekly, $daily, $isEnabled = true)
	{
		if (!in_array((string) strtoupper($weekly), $this->backupSchedules['weekly'])) {
			throw new Exception('Passed weekly back-up parameter is not supported');
		}

		if (!in_array((string) strtoupper($daily), $this->backupSchedules['daily'])) {
			throw new Exception('Passed daily back-up parameter is not supported');
		}

		$this->resource = '/servers/' . (int) $serverId . '/backup_schedule';
		$this->request = array('backupSchedule' => array(
									'enabled' => (bool) $isEnabled,
									'weekly' => (string) strtoupper($weekly),
									'daily' => (string) strtoupper($daily)));
		$this->request(self::METHOD_POST);

		if ($this->responseCode == 204) {
			return true;
		}

		return false;
	}

	/**
	 * Deletes scheduled back-up for specific server
	 *
	 * @param int $serverId id of server you wish to delete all
	 * scheduled back-ups for
	 * @return bool returns true on success or false on failure
	 */
	public function deleteBackupSchedule($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId
									. '/backup_schedule';
		$this->request(self::METHOD_DELETE);

		if ($this->responseCode == 204) {
			return true;
		}

		return false;
	}

	/**
	 * Creates a new server on the cloud
	 *
	 * @param string $name server name, must be unique
	 * @param int $imageId server image you wish to use
	 * @param int $flavorId server flavor you wish to use
	 * @param int $groupId optional group id of server cluster
	 * @return mixed returns json string of server's configuration
	 * or false on failure
	 */
	public function createServer($name, $imageId, $flavorId, $groupId = false)
	{
		// Since Rackspace automaticly removes all spaces/non
		// alpha-numeric characters  let's do this on our end before
		// submitting data
		$name = preg_replace("/[^a-zA-Z0-9s]/", '', (string) $name);

		// We need to check if we are creating a duplicate server name,
		// since creating two servers with same name can cause problems.
		$this->getServers();

		foreach ($this->servers as $server) {
			if (strtolower($server['name']) == strtolower($name)) {
				throw new Exception('Server with name: ' . $name . ' already exists!');
			}
		}

		$this->resource = '/servers';
		$this->request = array('server' => array(
									'name' => $name,
									'imageId' => (int) $imageId,
									'flavorId' => (int) $flavorId,
									'metadata' => array(
										'Server Name' => $name),
									'personality' => array()));

		if (is_array($this->files) && !empty($this->files)) {
			foreach ($this->files as $file => $content) {
				array_push(
					$this->request['server']['personality'],
					array(
						'path' => $file,
						'contents' => base64_encode($content)
					)
				);
			}
		}

		if (is_numeric($groupId)) {
			$this->request['server']['sharedIpGroupId'] = (int) $groupId;
		}

		$this->request(self::METHOD_POST);

		if ($this->responseCode == 202) {
			return $this->response;
		}

		return false;
	}

	/**
	 * Adds file to inject while creating new server
	 *
	 * @param string $file full file path where file will
	 * be put (/etc/motd,etc)
	 * @param string $content content of the file
	 * (Welcome to my server, etc)
	 * @return array returns array of all files pending injection
	 */
	public function addServerFile($file, $content)
	{
		$this->files[(string) $file] = (string) $content;
		return $this->files;
	}

	/**
	 * Update server's name and password
	 *
	 * @param int $serverId id of server you wish to update
	 * @param string $name new server name
	 * @param string $password new server password
	 * @return mixed returns false on failure or server configuration
	 * on success
	 */
	public function updateServer($serverId, $name, $password)
	{
		$this->resource = '/servers/' . (int) $serverId;
		$this->request = array('server' => array(
									'name' => (string) $name,
									'adminPass' => (string) $password));
		$this->request(self::METHOD_PUT);

		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Delete server
	 *
	 * @param int $serverId id of server you wish to delete
	 * @return bool returns true on success or false on fail
	 */
	public function deleteServer($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId;
		$this->request(self::METHOD_DELETE);

		// If server was deleted
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Rebuild server using another server image
	 *
	 * @param int $serverId id of server you wish to rebuild
	 * @param int $imageId id of server image you wish to use for
	 * this rebuild
	 * @return bool returns true on success or false on fail
	 */
	public function rebuildServer($serverId, $imageId)
	{
		$this->resource = '/servers/' . (int) $serverId . '/action';
		$this->request = array('rebuild' => array(
									'imageId' => (int) $imageId));
		$this->request(self::METHOD_PUT);

		// If rebuild request is successful
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Resize server to another flavor (server configuration)
	 *
	 * @param int $serverId id of server you wish to resize
	 * @param int $flavorId id of a flavor you wish to use as a starting point
	 * @return bool returns true on success or false on fail
	 */
	public function resizeServer($serverId, $flavorId)
	{
		$this->resource = '/servers/'. (int) $serverId . '/action';
		$this->request = array('resize' => array(
									'flavorId' => (int) $flavorId));
		$this->request(self::METHOD_PUT);

		// If confirmation is successful
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Confirm resize of server
	 *
	 * @param int $serverId id of server this confirmation is for
	 * @return bool returns true on success or false on fail
	 */
	public function confirmResize($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId . '/action';
		$this->request = array('confirmResize' => '1');
		$this->request(self::METHOD_PUT);

		// If confirmation is successful
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Revert resize changes
	 *
	 * @param int $serverId id of server you wish to revert resize for
	 * @return bool returns true on success or false on fail
	 */
	public function revertResize($serverId)
	{
		$this->resource = '/servers/' . (int) $serverId . '/action';
		$this->request = array('revertResize' => '1');
		$this->request(self::METHOD_PUT);

		// If revert is successful
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}

	/**
	 * Reboots server
	 *
	 * @param int $serverId id of server you wish to reboot
	 * @param string $type specify what kind of reboot you wish to perform
	 * @return bool returns true on success or false on fail
	 */
	public function rebootServer($serverId, $type = 'soft')
	{
		$this->resource = '/servers/' . (int) $serverId . '/action';
		$this->request = array('reboot' => array(
									'type' => (string) strtoupper($type)));
		$this->request(self::METHOD_POST);

		// If reboot request was successfully recieved
		if ($this->responseCode == 202) {
			return true;
		}

		return false;
	}
}

